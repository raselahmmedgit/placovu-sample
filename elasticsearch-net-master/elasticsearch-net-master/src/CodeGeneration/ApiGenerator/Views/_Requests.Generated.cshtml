@using System.Collections.Generic
@using System.Linq
@using System.Net.Cache
@using ApiGenerator.Domain
@using ApiGenerator

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Linq.Expressions;
using Elasticsearch.Net;
using Newtonsoft.Json;

//This file contains all the typed querystring parameters that are generated of the client spec.
//This file is automatically generated from https://github.com/elastic/elasticsearch/tree/@Model.Commit/rest-api-spec
//Generated from commit @Model.Commit

namespace Nest
{
@{
	RestApiSpec m = Model;
	var methods = m.CsharpMethodsWithQueryStringInfo
		.Concat(m
			.CsharpMethodsWithQueryStringInfo
			.Where(s=>s.RequestTypeGeneric == "<T>")
			.Select(s=> { var ss = CsharpMethod.Clone(s); ss.RequestTypeGeneric = ""; ss.SkipInterface = true; return ss; })
		)
		.OrderBy(s=>s.RequestType);
}
	@foreach (CsharpMethod method in methods)
	{
	if (!method.SkipInterface)
	{
	<text>
	[JsonObject(MemberSerialization = MemberSerialization.OptIn)]
	public partial interface @(Raw(method.InterfaceType)) : IRequest@(Raw(string.Format("<{0}>", method.QueryStringParamName))) 
	{</text>
	foreach (ApiUrlPart part in method.AllParts.Where(p=>!ApiUrl.BlackListRouteValues.Contains(p.Name)))
	{
		<text>@(Raw(part.ClrTypeName)) @(part.InterfaceName) { get; }</text>
	}
	<text> } </text>
	}
	<text>///<summary>Request parameters for @method.FullName <pre>@method.Documentation</pre></summary>
	public partial class @Raw(method.RequestType + method.RequestTypeGeneric) @Raw(string.Format(" : PlainRequestBase<{0}>, {1}", method.QueryStringParamName, method.InterfaceType))
	{
		protected @(Raw(method.InterfaceType)) Self => this;
	@foreach (ApiUrlPart part in method.AllParts.Where(p=>!ApiUrl.BlackListRouteValues.Contains(p.Name)))
	{
	<text>	@(Raw(part.ClrTypeName)) @(Raw(method.InterfaceType)).@(part.InterfaceName) => Self.RouteValues.Get@(Raw(string.Format("<{0}>",part.ClrTypeName)))("@(part.Name)");</text>
	}
	@foreach (Constructor c in method.RequestConstructors())
    {
	<text>	@(Raw(c.Description))
		@(Raw(c.Generated))
		@(Raw(c.AdditionalCode))
</text>
	}
	@foreach (KeyValuePair<string, ApiQueryParameters> kv in method.Url.Params)
	{
		if (method.Url.Parts != null && method.Url.Parts.ContainsKey(kv.Key))
        {
			continue;
        }
		var original = kv.Value.OriginalQueryStringParamName;
		var cased = kv.Key.ToPascalCase();
		var mm = (cased != "Type" && cased != "Index" && cased != "Script") ? cased : cased + "QueryString";
		var fieldType = kv.Value.HighLevelType(kv.Key).Replace("params", "");
		var isFields = (original.Contains("fields") || original.Contains("source_include") || original.Contains("source_exclude"));
		if (isFields && fieldType.Contains("string"))
		{
			fieldType = "Fields";
		}
		else if (original.Contains("field") && fieldType.Contains("string"))
		{
			fieldType = "Field";
		}
		var setter = "value";
		if (fieldType == "Time")
		{
			setter += ".ToString()";
		}
		<text>///<summary>@kv.Value.Description</summary>
		@if(!string.IsNullOrWhiteSpace(kv.Value.DeprecatedInFavorOf))
		{
		<text>[Obsolete("Scheduled to be removed in 5.0, use @kv.Value.DeprecatedInFavorOf instead")]</text>
		}
		@Raw(kv.Value.Generator.Invoke(fieldType, mm, original, setter))
		</text>
	}
	@if (method.RequestTypeUnmapped)
	{<text>	//TODO THIS METHOD IS UNMAPPED!
	</text>
	}
	}</text>
	}
}
 